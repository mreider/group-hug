h3. Building the Group Hug Rails app

These steps show you how to build a the Group Hug Rails application and deploy it on the Engine Yard Cloud. If you prefer video over written tutorials, you can view the "screencast here":http://engineyard.com/university. 

h4. Install Ruby, Rails, and create the app

* To install Rails on Windows, you can use the "Rails Installer":http://railsinstaller.org. 

* On OSX or Linux, you can use RVM by entering the following in your terminal ( see "prerequisites here":http://icanhazrails.com/user/prereqs ):

p(codey). curl -O -L http://rvm.beginrescueend.com/src/bootstrap_rails_environment && source ./bootstrap_rails_environment

* Create rails app:

p(codey). rails new grouphug

* Install facebooker2 as a plugin. This is a popular library for interfacing Rails applications with Facebook. "The github for Facebookr2 is here":https://github.com/mmangino/facebooker2

p(codey). script/rails plugin install git://github.com/mmangino/facebooker2.git

p(clues). *What's a plugin?* Watch a  screen cast by Ryan Bigg

p(clues). *What's Facebooker2* Watch a screen cast by Christopher Johnson

h4. Create a Facebook application 

* Login to Facebook and visit "http://www.facebook.com/developers/createapp.php":http://www.facebook.com/developers/createapp.php.

* We need to create two Facebook applications, one for development, and one for production. Name the first one something fun, with @_development@ at the end. We called ours icanhazrails_development.

!http://icanhazrails.com/images/fbapp.png(fb create app)!

* Click Create App

* Go to the Website settings, and set the site URL to the IP address of your computer.

!http://icanhazrails.com/images/wurl.png(fb website settings)!

h4. Configure Facebooker in Rails

* Copy the settings from your Facebook application page. To find your settings, go to "the facebook developer page":http://www.facebook.com/developers/ and click on the application you created. The page should appear as follows:

!http://icanhazrails.com/images/appsettings.png(fb app settings)!

* Create @config/facebooker.yml@ and paste the settings from your application page as follows:

p(codey). development:
&nbsp; app_id: your application id
&nbsp; secret: your application secret
&nbsp; api_key: your application key

* Create @config/initializers/facebooker2.rb@ and place the following line in it.

p(codey). Facebooker2.load_facebooker_yaml

p(clues). *What's YAML?* Watch a screen cast by Matt Reider

* Add the following line to @app/controllers/application_controller.rb@

p(codey). include Facebooker2::Rails::Controller

p(clues). *What's a Controller?* Watch a screen cast by Ryan Bigg

h4. Creating the Layout

* In rails, there is a special Layout in @app/views/layouts/application.html.erb@. This file will be sent to the browser no matter what page is sent. It's the perfect place to put headers and footers. Place some standard HTML in that file, and include the Ruby @yield@ method as the placeholder for running the actual page that was requested.

p(clues). *What's a Layout?* Watch a screen cast by Ryan Bigg

p(codey). &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
&lt;title&gt;An XHTML 1.0 Strict standard template&lt;/title&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%= yield %&gt;
&lt;/body&gt;
&lt;/html&gt;

* Put some more code into @app/views/layouts/application.html.erb@ to display the Facebook login button on every page. The conditional logic will replace the login button with the user's name, if he/she is already logged in. Here we are using embedded ruby. Put this code above the yield method:

p(codey). &lt;%# include JavaScript to use facebook connect%&gt;
&lt;%=fb_connect_async_js%&gt;
&lt;%if current_facebook_user !=nil%&gt;
&lt;%=&quot;Welcome #{@current_user.name}!&quot;  if @current_user !=nil%&gt;
&lt;%=fb_logout_link(&quot;Logout&quot;, request.url)%&gt;&lt;br /&gt;
&lt;%else%&gt;
&lt;%=fb_login_and_redirect( url_for(:action =&gt; 'create', :controller =&gt; 'user', :only_path =&gt; false), :perms =&gt; 'email,user_groups,read_stream, publish_stream')%&gt;
&lt;%end%&gt;

p(clues). *What's Embedded Ruby?* Watch a screen cast by Christopher Johnson
	
* Create the model to store application users

p(codey). rails generate model User

p(clues). *What's a Model?* Watch a screen cast by Ryan Bigg
	
* Then create a database migration file by typing

p(codey). rails generate migration create_users

p(clues). *What's a Database Migration?* Watch a screen cast by Ryan Bigg

This creates a file in the folder @db/migrate/@ named something like @20110203050933_create_users.rb@

p(codey). class CreateUsers < ActiveRecord::Migration
&nbsp;def self.up
&nbsp;&nbsp;create_table :users do |t|
&nbsp;&nbsp;t.string :email, :name, :facebook_id, :facebook_session_key, t.timestamps
&nbsp;&nbsp;end
&nbsp;end
&nbsp;
&nbsp;def self.down
&nbsp;&nbsp;drop_table :users
&nbsp;end
end

* Run the migration
  
p(codey). rake db:migrate
  
* Create the user controller and login action
   
p(codey). rails generate controller User

* Open the page you just created @app/controllers/user_controllers.rb@

* Create an empty action for the login page, this will just show the login button, which we already put on the application.html.erb page.

p(codey). def login
end

* Create two other methods  in the same controller, underneath the login action. The first action will be called @create@ and it will create a session. The second one will be called create_via_facebook_connect and it is called from the former method to grab the user id for this facebook user from the local database, or create a new record if the user has never signed into group hug before. 

p(codey). def create
&nbsp;&#64;user = User.find_by_email(params[:email]) 
&nbsp;create_via_facebook_connect if &#64;user.nil?
&nbsp;if &#64;user != nil 
&nbsp;&nbsp;session[:user_id] = &#64;user.id
&nbsp;&nbsp;redirect_to url_for(groups_path)
&nbsp;&nbsp;session[:return_to]=nil
&nbsp;else
&nbsp;&nbsp;flash[:error] = "Unable to log you in"
&nbsp;&nbsp;render :action=>"login"
&nbsp;end
end
&nbsp;
def create_via_facebook_connect
&nbsp;if current_facebook_user 
&nbsp;&nbsp;#look for an existing user
&nbsp;&nbsp;&#64;user = User.find_by_facebook_id(current_facebook_user.id)	  
&nbsp;&nbsp;if &#64;user.nil?
&nbsp;&nbsp;&nbsp;#if one isn't found - fetch user data via Mogli lib and create new user
&nbsp;&nbsp;&nbsp;current_facebook_user.fetch
&nbsp;&nbsp;&nbsp;&#64;user = User.new(:name => current_facebook_user[:name], :email => current_facebook_user[:email], :facebook_id => current_facebook_user[:id], :facebook_session_key => current_facebook_client.access_token)
&nbsp;&nbsp;&nbsp;&#64;user.save
&nbsp;&nbsp;end
&nbsp;end
end

* Create an empty view for the login page ( @app/views/user/login.html.erb@ ). Remember, the login button is actually in the application.html.erb page, which puts it on every view.
  
* Edit the view as follows:

p(codey). def create
&nbsp;&#64;user = User.find_by_email(params[:email])
&nbsp;create_via_facebook_connect if &#64;user.nil?
&nbsp;if &#64;user != nil 
&nbsp;&nbsp;session[:user_id] = &#64;user.id
&nbsp;&nbsp;redirect_to url_for(groups_path)
&nbsp;&nbsp;session[:return_to]=nil
&nbsp;else
&nbsp;&nbsp;flash[:error] = "Unable to log you in"
&nbsp;&nbsp;render :action=>"login"
&nbsp;end
end
&nbsp;
def create_via_facebook_connect
&nbsp;if current_facebook_user 
&nbsp;&nbsp;#look for an existing user
&nbsp;&nbsp;&#64;user = User.find_by_facebook_id(current_facebook_user.id)	  
&nbsp;&nbsp;if &#64;user.nil?
&nbsp;&nbsp;&nbsp;#if one isn't found - fetch user data via Mogli lib and create new user
&nbsp;&nbsp;&nbsp;current_facebook_user.fetch
&nbsp;&nbsp;&nbsp;&#64;user = User.new(:name => current_facebook_user[:name], :email => current_facebook_user[:email], :facebook_id => current_facebook_user[:id], :facebook_session_key => current_facebook_client.access_token)
&nbsp;&nbsp;&#64;user.save
&nbsp;&nbsp;end
&nbsp;end
end

* After successful login users will go to groups controller.  Let's create a groups controller first:

p(codey). rails generate controller Groups
	  
* Now we can edit @config/routes.rb@ to send people to the groups controller whenever a url is requested with the verb 'groups' after the domain name. For instance @http://icanhazrails.com/groups@ will load the controller @app/controllers/groups_controller.rb@. You created that controller when you typed the generate command in the last step.
    
p(codey). resources :groups 
   
* Set the home page to login
   
p(codey). resources :groups root :to => "user#login"

* Use standard '<controller>/<action>'	routes by uncommenting the line in your @config/routes.rb@
   
p(codey). match ':controller(/:action(/:id(.:format)))'
	   
* Add methods to ApplicationController ( @app/controllers/application_controller.rb@ ) to check if the user has logged in and determine his/her user id. Things in the ApplicationController are available to every controller in the application.

p(codey). def current_user
&nbsp;if session[:user_id]
&nbsp;&nbsp;&#64;current_user ||= User.find(session[:user_id])
&nbsp;elsif current_facebook_user and &#64;current_user.nil?
&nbsp;&nbsp;&#64;current_user = User.find_by_facebook_id(current_facebook_user.id)
&nbsp;end
end
	  
* Next, we make the above code a helper method. This is a bit of trickery in that usually helper methods are created in their own files under the helpers directory and are more useful in views, rather than controllers, because they are visual. We will create non-tricky helper methods in a few minutes. This tricky one is turned into a helper method using the @helper_method@ method.

p(clues). *What's a Helper Method?* Watch a screen cast by Ryan Bigg

p(codey). helper_method :current_user

* Also in the ApplicationController is a method for checking if the user is logged in.
	  
p(codey). def login_required
&nbsp;if current_user.nil?
&nbsp;&nbsp;flash[:notice] = "You must login to access this page"
&nbsp;&nbsp;session[:return_to] = request.request_uri
&nbsp;&nbsp;redirect_to :controller =>'user', :action =>'login' and return
&nbsp;end
end

* Next we edit the groups controller @app/controllers/groups_controller.rb@. The first thing we will do is add the before_filter method, which basically intercepts every request to the controller, and runs certain method before anything else has a chance. In this case, we are going to run the login_required method to make sure the user is logged in.

p(codey). before_filter :login_required

* Then we define the default behavior (index) for the group controller	  

p(codey). def index 
&nbsp;#get current users groups
&nbsp;&#64;groups = current_facebook_user.groups
&nbsp;#determine selected user group or get first group id if default group is not selected
&nbsp;&#64;default_group = &#64;current_user.default_group
&nbsp;&#64;default_group = &#64;groups.first.id if &#64;default_group.nil? && &#64;groups.first != nil
&nbsp;if (params[:current_group] != nil)
&nbsp;&nbsp;&#64;current_group = params[:current_group]
&nbsp;else
&nbsp;&nbsp;&#64;current_group = &#64;default_group
&nbsp;end
end
	
* Open the groups view ( @app/views/groups/index.html.erb@ ). This was automagically created when you generated the controller.

* Add some HTML and embedded ruby to this view. This creates a select box of all the groups the user has on Facebook. The inner HTML of the posts container will be replaced with the group posts from Facebook using JQuery in a minute.

p(codey). &lt;select name=&quot;group&quot; id=&quot;group&quot;&gt;
&lt;% @groups.each do |group| %&gt;
&lt;option value=&quot;&lt;%=group.id%&gt;&quot; &lt;%= 'selected' if @default_group == group.id %&gt;&gt;&lt;%=group.name%&gt;&lt;/option&gt;
&lt;% end %&gt;
&lt;/select&gt;
&lt;br/&gt;
&lt;input id=&quot;def_group&quot; name=&quot;def_group&quot; type=&quot;checkbox&quot; selected=&quot;false&quot; /&gt; Default group &lt;br/&gt;
&lt;div id=&quot;posts_container&quot; &gt;Posts&lt;/div&gt;
		
* Install jQuery via the instructions at @https://github.com/lleger/Rails-3-jQuery/@

p(clues). *How does JQuery work?* Watch a screen cast by Matt Dolian

* We need to tell Rails to load any Javascript (JQuery in particular) that is sent to the page. You will see how to send it in a moment. Right now, we're just receiving it. Go back and edit the @app/viewslayouts/application.html.erb@ and put this up in the header of your HTML document.

p(clues). &lt;script&gt; 
&lt;%= yield (:javascript) %&gt;
&lt;/script&gt;


		
		<% content_for (:javascript) do %>
		$(document).ready(function() {
		  // bind checkbox change
		  $('#def_group').bind('change', function() {
			var group_id = $(this).is(':checked') ? $('#group').val() : 'nil'
			$.post('/groups/set_default/' + group_id ,  function() {
			  alert ('Default group was saved');
			});
			//chenge default group
			def_group = group_id == 'nil' ? null : group_id;
		  });
		 
		 
		});


		
		<% end %>

     So now we have combo box with all user groups.
	 
14. Implement default group save in GroupsController

	  def set_default
		render :json => { :result => @current_user.update_attributes(:default_group => params['id'] == 'nil' ? nil : params['id']) }
	  end

15. Implement Posts in current group displaying. 
     
	 rails generate controller Groups
	 
	Lets use nested resouces to relate groups and posts. Setup routes this way:
	
	  resources :groups do
		resources :posts
	  end
	
16. Call Posts List in groups view via jQuery:

    Implement 'change' event in document.ready block:

	  // bind select group
	  $('#group').bind('change', function() {
		$('#posts_container').html('<p>Loading...</p>');
		loadData('/groups/' + $(this).val() + '/posts', null)

		//check if current group is default and mark checkbox checked or not
		$('#def_group').attr('checked', $(this).val() == def_group);
	  });

		function loadData(rem_url, params) {
		  var temp = rem_url; 
		  if (params != null ) {
			temp += '?' + params;
		  }
		  $('#loading_div').show();
		  
		  $.ajax({ url: temp,
		  dataType: 'json',
		  type: 'GET',
		  error: function(req,data) {
			alert("Error getting remote data: " + data);
			$('#loading_div').hide();
		  },
		  success: function(data) {
			$('#loading_div').hide();
			$('#posts_container').html(data.html);
			if (data.next != null) {
				$('#next_btn').show();
				$('#next_btn').unbind('click');
				$('#next_btn').click(function () { 
					loadData(rem_url, 'next=' + data.next);
				});
			} else {
				$('#next_btn').css('display', 'none');
			}	
			if (data.prev != null) {
				$('#prev_btn').show();
				$('#prev_btn').unbind('click');
				$('#prev_btn').click(function () { 
					loadData(rem_url, 'next=' + data.prev);
				});
			} else {
				$('#prev_btn').css('display', 'none');
			}
			FB.XFBML.parse(document.getElementById('posts_container'));
		  }
		  });

		}

	  And implement default group display on page load:
	  
	  $('#posts_container').load('/groups/<%=@default_group%>/posts',  function() {
		FB.XFBML.parse(document.getElementById('posts_container'));
  
	  });

	Posts controller will return user images in FBML, so we must parse FBML via FB.XFBML.parse
	 
17. Posts list in selected group to insert via AJAX:

	  def index    
		@group = Mogli::Group.new({:id=>params['group_id']}, current_facebook_client)
		@group.fetch
		
		#getting posts for page 0
		@posts = @group.feed
		render :layout => false
	  end

     view template can be like:
	 
	<% @posts.each do |post| %>

	<div style="clear:both">
	  <span style="float:left;width:55px">
		<fb:profile-pic uid="<%=post.from.id%>" linked="false" size="q"></fb:profile-pic>
	  </span>
	  <span>
		<%=post.message%><br/> 
		<%=time_ago_in_words(post.updated_time) %> ago
	  </span>
	</div>

	<% end %>
	 

18. Link to post new message used nested resource path:

	<%= link_to "Post", url_for(new_group_post_path(@group.id)) %>	
	
19. Display form to post message to group. PostsController get current group to display name:

	  def new
		@group = Mogli::Group.new({:id=>params['group_id']}, current_facebook_client)
		@group.fetch
	  end

	and simple view:
	
	<h1>Post a wall message to: <%= @group.name %></h1>

	<% form_tag  url_for(group_posts_path(@group.id)), :method=>:post do -%>
	 
	  
	  <%= hidden_field_tag 'group_id', @group.id %>
	  
	  <div class="field">
		<%= text_area_tag 'message', nil, :rows => 10, :cols => 60 %>
	  </div>
	  <div class="field">
		<%= check_box_tag 'send_via_email', 'yes', true %> Send the whole group an email
	  </div>
	  <div class="actions">
		<%= submit_tag 'Save' %>
	  </div>
	<% end -%>
	 
	<%= link_to 'Back', url_for(groups_path) %>

20. Form submited to create action

	  def create
		@group = Mogli::Group.new({:id=>params['group_id']}, current_facebook_client)
		@group.fetch

		if current_facebook_user
		  current_facebook_client.class.post(current_facebook_client.api_path(@group.id + '/feed'),
				:query=>current_facebook_client.default_params.merge(
						   {:name => "#{current_facebook_user.name} Post a message using app!",
							:link=>'http://staging.operations.engineyard.com/groups',
							:message=>params['message']})).inspect
		end
		redirect_to groups_path	
	  end

21. Run your app via 'rackup' command

22. Implementing pagging for posts.
Facebook Graph API return only first 25 posts, also it provide links to get next and previous items.
So for pagging lets implement server side functionlity to return json data with list html(like it works now), next and previous pages.

22.1 Server side implementation in posts_controller.rb:

  def index    
    @group = Mogli::Group.new({:id=>params['group_id']}, current_facebook_client)
	@group.fetch
	
	#getting posts for page 0
    @posts = @group.feed
	@page = 0
	
	if params[:next]
	  #if 'next' parameter passed - lets get page to display
	  @page = params[:next].to_i 
	  
	  # and get api url to get next or previous page
	  rest_url = (session[:page] < @page) ? session[:posts_next] : session[:posts_prev]
	  
	  # getting posts and map them to appropriate Mogli class
	  @posts = current_facebook_client.get_and_map_url(rest_url,@posts.classes)
	end
	
	# setting data to session to get url if user want to see next
	session[:posts_next] = @posts.next_url
	session[:posts_prev] = @posts.previous_url 
    session[:page] = @page
	
	# render template to string
	html = render_to_string :template => "posts/index.html.erb", :layout => false
	
	# produce json output with html, next and previous pages.
	render :json => {
	  :html => html,
	  :next => @page + 1,
	  :prev => @page > 0 ? @page - 1 : nil
    }
  end

22.2. Implementing client side html in \views\groups\index.html:
 
<div id="posts_container" ></div>

<div id="loading_div"  style="display:none" ><%= image_tag "loading-spinner.gif", :alt => "Loading" %></div>

<div>
<input type="button" value="Previous" id="prev_btn" class="prvnxt" style="display:none"> <input type="button" value="Next" id="next_btn" class="prvnxt" style="display:none">
</div>

22.3. and JavaScript in \views\groups\index.html:

<% content_for (:javascript) do %>
var def_group = '<%=@default_group%>';
$(document).ready(function() {
  // bind select group
  $('#group').bind('change', function() {
    $('#posts_container').html('<p>Loading...</p>');
	loadData('/groups/' + $(this).val() + '/posts', null)

	//check if current group is default and mark checkbox checked or not
	$('#def_group').attr('checked', $(this).val() == def_group);
  });

  // preload default group
  loadData('/groups/<%=@default_group%>/posts', null);

  // bind checkbox change
  $('#def_group').bind('change', function() {
	var group_id = $(this).is(':checked') ? $('#group').val() : 'nil'
	$.post('/groups/default/' + group_id ,  function() {
	  alert ('Default group was saved');
	});
	//chenge default group
	def_group = group_id == 'nil' ? null : group_id;
  });
    
  });  
    
// load data to 'posts_container' and 
// display/hide 'Next' and 'Previous' buttons depending of returned json
function loadData(rem_url, params) {
  var temp = rem_url; 
  if (params != null ) {
    temp += '?' + params;
  }
  $('#loading_div').show();
  
  $.ajax({ url: temp,
  dataType: 'json',
  type: 'GET',
  error: function(req,data) {
    alert("Error getting remote data: " + data);
    $('#loading_div').hide();
  },
  success: function(data) {
    $('#loading_div').hide();
    $('#posts_container').html(data.html);
	if (data.next != null) {
		$('#next_btn').show();
		$('#next_btn').unbind('click');
		$('#next_btn').click(function () { 
			loadData(rem_url, 'next=' + data.next);
		});
	} else {
		$('#next_btn').css('display', 'none');
    }	
	if (data.prev != null) {
		$('#prev_btn').show();
		$('#prev_btn').unbind('click');
		$('#prev_btn').click(function () { 
			loadData(rem_url, 'next=' + data.prev);
		});
	} else {
		$('#prev_btn').css('display', 'none');
	}
	FB.XFBML.parse(document.getElementById('posts_container'));
  }
  });

}

<% end %>

h4. Create the second Facebook app for production.

* Go back and create another Facebook application for your production application. Name it the same thing minus the @_development@ bit.

!http://icanhazrails.com/images/anotherFB.png(fb app settings again)!

* Go back to the facebooker.yml file. Under your development settings, set your

